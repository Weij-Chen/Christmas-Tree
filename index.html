<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Christmas Tree</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Playfair+Display:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "three": "https://esm.sh/three@0.158.0",
        "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.11",
        "@react-three/drei": "https://esm.sh/@react-three/drei@9.88.13",
        "framer-motion": "https://esm.sh/framer-motion@10.16.4"
      }
    }
    </script>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            background: #010b07; 
            overflow: hidden; 
            font-family: 'Cinzel', serif;
        }
        ::-webkit-scrollbar { width: 0px; background: transparent; }
        
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #FFD700;
            font-size: 1.5rem;
            z-index: 1000;
        }
        
        .error {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff6b6b;
            font-size: 1.2rem;
            text-align: center;
            z-index: 1000;
            max-width: 80%;
        }
    </style>
</head>
<body>
    <div id="root">
        <div class="loading">ðŸŽ„ Loading Christmas Magic... ðŸŽ„</div>
    </div>

    <script type="module">
        try {
            // Import React and other dependencies
            const React = await import('react');
            const { createRoot } = await import('react-dom/client');
            const { Canvas, useFrame } = await import('@react-three/fiber');
            const { OrbitControls, Environment, PerspectiveCamera, Stars } = await import('@react-three/drei');
            const THREE = await import('three');
            const { motion } = await import('framer-motion');

            const { useState, useRef, useMemo } = React;

            // Tree configuration
            const FOLIAGE_COUNT = 8000;
            const TREE_CONFIG = {
                height: 12,
                radiusBase: 4.5,
                scatterRadius: 18,
            };

            // Tree states
            const TreeMorphState = {
                SCATTERED: 'SCATTERED',
                TREE_SHAPE: 'TREE_SHAPE',
            };

            // Simple particle system component
            const FoliagePoints = ({ morphTarget }) => {
                const pointsRef = useRef();
                const materialRef = useRef();

                const { positions, colors, sizes } = useMemo(() => {
                    const positions = new Float32Array(FOLIAGE_COUNT * 3);
                    const colors = new Float32Array(FOLIAGE_COUNT * 3);
                    const sizes = new Float32Array(FOLIAGE_COUNT);

                    for (let i = 0; i < FOLIAGE_COUNT; i++) {
                        const i3 = i * 3;
                        
                        // Random positions
                        positions[i3] = (Math.random() - 0.5) * 20;
                        positions[i3 + 1] = (Math.random() - 0.5) * 20;
                        positions[i3 + 2] = (Math.random() - 0.5) * 20;
                        
                        // Green colors with variation
                        colors[i3] = 0.1 + Math.random() * 0.3; // R
                        colors[i3 + 1] = 0.4 + Math.random() * 0.4; // G
                        colors[i3 + 2] = 0.1 + Math.random() * 0.2; // B
                        
                        sizes[i] = Math.random() * 3 + 1;
                    }

                    return { positions, colors, sizes };
                }, []);

                useFrame((state) => {
                    if (pointsRef.current && materialRef.current) {
                        const time = state.clock.elapsedTime;
                        
                        // Update positions based on morph target
                        const positionArray = pointsRef.current.geometry.attributes.position.array;
                        
                        for (let i = 0; i < FOLIAGE_COUNT; i++) {
                            const i3 = i * 3;
                            
                            // Tree shape calculation
                            const y = (Math.random() - 0.2) * TREE_CONFIG.height;
                            const normY = 1 - (y + TREE_CONFIG.height * 0.2) / TREE_CONFIG.height;
                            const radiusAtHeight = Math.max(0, normY * TREE_CONFIG.radiusBase);
                            const angle = Math.random() * Math.PI * 2;
                            const r = Math.sqrt(Math.random()) * radiusAtHeight;
                            
                            const treeX = Math.cos(angle) * r;
                            const treeY = y;
                            const treeZ = Math.sin(angle) * r;
                            
                            // Scatter positions
                            const scatterX = (Math.random() - 0.5) * TREE_CONFIG.scatterRadius * 2;
                            const scatterY = (Math.random() - 0.5) * TREE_CONFIG.scatterRadius * 2;
                            const scatterZ = (Math.random() - 0.5) * TREE_CONFIG.scatterRadius * 2;
                            
                            // Interpolate between scatter and tree positions
                            positionArray[i3] = scatterX + (treeX - scatterX) * morphTarget + Math.sin(time + i) * 0.1;
                            positionArray[i3 + 1] = scatterY + (treeY - scatterY) * morphTarget + Math.cos(time + i) * 0.1;
                            positionArray[i3 + 2] = scatterZ + (treeZ - scatterZ) * morphTarget;
                        }
                        
                        pointsRef.current.geometry.attributes.position.needsUpdate = true;
                        
                        // Update material opacity
                        materialRef.current.opacity = 0.6 + 0.4 * morphTarget;
                    }
                });

                return React.createElement('points', { ref: pointsRef }, [
                    React.createElement('bufferGeometry', { key: 'geometry' }, [
                        React.createElement('bufferAttribute', {
                            key: 'position',
                            attach: 'attributes-position',
                            count: FOLIAGE_COUNT,
                            array: positions,
                            itemSize: 3
                        }),
                        React.createElement('bufferAttribute', {
                            key: 'color',
                            attach: 'attributes-color',
                            count: FOLIAGE_COUNT,
                            array: colors,
                            itemSize: 3
                        }),
                        React.createElement('bufferAttribute', {
                            key: 'size',
                            attach: 'attributes-size',
                            count: FOLIAGE_COUNT,
                            array: sizes,
                            itemSize: 1
                        })
                    ]),
                    React.createElement('pointsMaterial', {
                        key: 'material',
                        ref: materialRef,
                        size: 0.1,
                        vertexColors: true,
                        transparent: true,
                        opacity: 0.8,
                        sizeAttenuation: true
                    })
                ]);
            };

            // Simple star component
            const TopStar = ({ morphTarget }) => {
                const starRef = useRef();

                useFrame((state) => {
                    if (starRef.current) {
                        const time = state.clock.elapsedTime;
                        starRef.current.rotation.y = time;
                        starRef.current.position.y = 6 + Math.sin(time * 2) * 0.2;
                        starRef.current.scale.setScalar(1 + Math.sin(time * 3) * 0.1);
                        
                        // Move between scatter and tree position
                        const scatterPos = [(Math.random() - 0.5) * 20, (Math.random() - 0.5) * 20, (Math.random() - 0.5) * 20];
                        const treePos = [0, 6, 0];
                        
                        starRef.current.position.x = scatterPos[0] + (treePos[0] - scatterPos[0]) * morphTarget;
                        starRef.current.position.z = scatterPos[2] + (treePos[2] - scatterPos[2]) * morphTarget;
                    }
                });

                return React.createElement('mesh', { ref: starRef }, [
                    React.createElement('coneGeometry', { key: 'geometry', args: [0.5, 1, 5] }),
                    React.createElement('meshStandardMaterial', {
                        key: 'material',
                        color: '#FFD700',
                        emissive: '#FFD700',
                        emissiveIntensity: 0.5
                    })
                ]);
            };

            // 3D Experience component
            const Experience = ({ treeState }) => {
                const morphTarget = treeState === TreeMorphState.TREE_SHAPE ? 1.0 : 0.0;

                return React.createElement(Canvas, {
                    gl: { antialias: true, alpha: false },
                    dpr: [1, 2],
                    shadows: true
                }, [
                    React.createElement('color', { key: 'bg', attach: 'background', args: ['#000502'] }),
                    React.createElement(PerspectiveCamera, {
                        key: 'camera',
                        makeDefault: true,
                        position: [0, 2, 18],
                        fov: 45
                    }),
                    React.createElement(OrbitControls, {
                        key: 'controls',
                        enablePan: false,
                        minDistance: 8,
                        maxDistance: 25,
                        maxPolarAngle: Math.PI / 1.4,
                        autoRotate: treeState === TreeMorphState.TREE_SHAPE,
                        autoRotateSpeed: 0.5
                    }),
                    React.createElement(Environment, { key: 'env', preset: 'city' }),
                    React.createElement('ambientLight', { key: 'ambient', intensity: 0.2, color: '#001a0f' }),
                    React.createElement('spotLight', {
                        key: 'spot',
                        position: [10, 20, 10],
                        angle: 0.3,
                        penumbra: 1,
                        intensity: 2,
                        color: '#fff0d6',
                        castShadow: true
                    }),
                    React.createElement('pointLight', {
                        key: 'point',
                        position: [-10, -5, -10],
                        intensity: 1,
                        color: '#0b6e40'
                    }),
                    React.createElement('group', { key: 'scene', position: [0, -4, 0] }, [
                        React.createElement(FoliagePoints, { key: 'foliage', morphTarget }),
                        React.createElement(TopStar, { key: 'star', morphTarget })
                    ]),
                    React.createElement(Stars, {
                        key: 'stars',
                        radius: 100,
                        depth: 50,
                        count: 5000,
                        factor: 4,
                        saturation: 0,
                        fade: true,
                        speed: 1
                    })
                ]);
            };

            // Overlay component
            const Overlay = ({ treeState, toggleState }) => {
                const isTree = treeState === TreeMorphState.TREE_SHAPE;

                return React.createElement('div', {
                    className: 'absolute inset-0 pointer-events-none flex flex-col justify-between items-center p-8 z-10'
                }, [
                    React.createElement('header', { key: 'header', className: 'text-center mt-4' }, [
                        React.createElement('h1', {
                            key: 'title',
                            className: 'text-3xl md:text-5xl text-transparent bg-clip-text bg-gradient-to-b from-yellow-200 to-yellow-600 font-bold tracking-widest drop-shadow-lg uppercase',
                            style: { fontFamily: 'Cinzel, serif' }
                        }, 'Christmas Tree'),
                        React.createElement('h2', {
                            key: 'subtitle',
                            className: 'text-green-400 italic text-xl md:text-2xl mt-2 tracking-wide opacity-80',
                            style: { fontFamily: 'Playfair Display, serif' }
                        }, 'Merry Christmas')
                    ]),
                    React.createElement('div', {
                        key: 'controls',
                        className: 'mb-12 pointer-events-auto'
                    }, [
                        React.createElement('button', {
                            key: 'button',
                            onClick: toggleState,
                            className: `px-8 py-3 text-sm md:text-lg tracking-widest font-bold border border-yellow-500 transition-all duration-500 backdrop-blur-sm ${isTree ? 'bg-green-900 bg-opacity-20 text-yellow-400' : 'bg-transparent text-yellow-400'} hover:bg-yellow-500 hover:text-black`,
                            style: { fontFamily: 'Cinzel, serif' }
                        }, isTree ? 'SCATTER ESSENCE' : 'ASSEMBLE FORM')
                    ]),
                    React.createElement('div', {
                        key: 'footer',
                        className: 'absolute bottom-4 left-4 text-green-400 text-xs tracking-widest opacity-50',
                        style: { fontFamily: 'Cinzel, serif' }
                    }, 'INTERACTIVE 3D EXPERIENCE')
                ]);
            };

            // Main App component
            const App = () => {
                const [treeState, setTreeState] = useState(TreeMorphState.SCATTERED);

                const toggleState = () => {
                    setTreeState(prev => 
                        prev === TreeMorphState.SCATTERED 
                            ? TreeMorphState.TREE_SHAPE 
                            : TreeMorphState.SCATTERED
                    );
                };

                return React.createElement('div', {
                    className: 'w-full h-screen bg-black relative overflow-hidden'
                }, [
                    React.createElement('div', {
                        key: 'canvas',
                        className: 'absolute inset-0 z-0'
                    }, [
                        React.createElement(Experience, { treeState })
                    ]),
                    React.createElement(Overlay, {
                        key: 'overlay',
                        treeState,
                        toggleState
                    }),
                    React.createElement('div', {
                        key: 'border',
                        className: 'absolute inset-0 pointer-events-none border border-yellow-500 border-opacity-20 m-4 z-20'
                    })
                ]);
            };

            // Render the app
            const root = createRoot(document.getElementById('root'));
            root.render(React.createElement(App));

            console.log('ðŸŽ„ Christmas Tree loaded successfully! ðŸŽ„');

        } catch (error) {
            console.error('Error loading Christmas Tree:', error);
            document.getElementById('root').innerHTML = `
                <div class="error">
                    <h2>ðŸŽ„ Oops! Something went wrong ðŸŽ„</h2>
                    <p>Error: ${error.message}</p>
                    <p>Please try refreshing the page or check your internet connection.</p>
                    <br>
                    <p><strong>Alternative:</strong> Try opening <code>christmas-tree-standalone.html</code> instead.</p>
                </div>
            `;
        }
    </script>
</body>
</html>
