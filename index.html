<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Christmas Tree</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Playfair+Display:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            background-color: #010b07; 
            overflow: hidden; 
            font-family: 'Cinzel', serif;
        }
        ::-webkit-scrollbar { width: 0px; background: transparent; }
        .loading { 
            position: fixed; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            color: #FFD700; 
            font-size: 1.5rem; 
            z-index: 1000; 
            font-family: 'Cinzel', serif;
            text-align: center;
        }
        .error {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff6b6b;
            font-size: 1.2rem;
            text-align: center;
            z-index: 1000;
            max-width: 80%;
        }
    </style>
</head>
<body>
    <div id="root">
        <div class="loading">
            ğŸ„ Loading 3D Christmas Magic... ğŸ„<br>
            <small style="font-size: 0.8rem; opacity: 0.7;">Please wait while we load the particle system</small>
        </div>
    </div>

    <!-- åŠ è½½React -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- åŠ è½½Three.js -->
    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
    
    <script>
        // ç­‰å¾…æ‰€æœ‰åº“åŠ è½½å®Œæˆ
        window.addEventListener('load', function() {
            try {
                createApp();
            } catch (error) {
                console.error('Error creating app:', error);
                showError(error);
            }
        });
        
        function showError(error) {
            document.getElementById('root').innerHTML = `
                <div class="error">
                    <h2>ğŸ„ Oops! Something went wrong ğŸ„</h2>
                    <p>Error: ${error.message}</p>
                    <p>Please try refreshing the page or check your internet connection.</p>
                    <br>
                    <p><strong>Alternative:</strong> Try opening <code>christmas-tree-standalone.html</code> instead.</p>
                </div>
            `;
        }
        
        function createApp() {
            const { useState, useRef, useEffect } = React;
            
            // 3Dåœºæ™¯ç»„ä»¶
            const ThreeScene = ({ treeState }) => {
                const mountRef = useRef();
                const sceneRef = useRef();
                const rendererRef = useRef();
                const cameraRef = useRef();
                const particlesRef = useRef();
                const frameId = useRef();
                const timeRef = useRef(0);
                
                useEffect(() => {
                    if (!mountRef.current || !THREE) return;
                    
                    try {
                        // åˆ›å»ºåœºæ™¯
                        const scene = new THREE.Scene();
                        scene.background = new THREE.Color('#000502');
                        sceneRef.current = scene;
                        
                        // åˆ›å»ºç›¸æœº - ç¼©å°æ•´ä½“å°ºå¯¸
                        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
                        camera.position.set(0, 1, 12);
                        cameraRef.current = camera;
                        
                        // åˆ›å»ºæ¸²æŸ“å™¨
                        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
                        renderer.setSize(window.innerWidth, window.innerHeight);
                        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                        renderer.shadowMap.enabled = true;
                        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                        rendererRef.current = renderer;
                        mountRef.current.appendChild(renderer.domElement);
                        
                        // æ·»åŠ å…‰ç…§
                        const ambientLight = new THREE.AmbientLight('#001a0f', 0.2);
                        scene.add(ambientLight);
                        
                        const spotLight = new THREE.SpotLight('#fff0d6', 2);
                        spotLight.position.set(10, 20, 10);
                        spotLight.angle = 0.3;
                        spotLight.penumbra = 1;
                        spotLight.castShadow = true;
                        scene.add(spotLight);
                        
                        const pointLight = new THREE.PointLight('#0b6e40', 1);
                        pointLight.position.set(-10, -5, -10);
                        scene.add(pointLight);
                        
                        // åˆ›å»ºç²’å­ç³»ç»Ÿ - è¿™æ˜¯å…³é”®éƒ¨åˆ†ï¼
                        const particleCount = 12000; // å¢åŠ ç²’å­æ•°é‡
                        const positions = new Float32Array(particleCount * 3);
                        const scatterPositions = new Float32Array(particleCount * 3);
                        const treePositions = new Float32Array(particleCount * 3);
                        const colors = new Float32Array(particleCount * 3);
                        const sizes = new Float32Array(particleCount);
                        const randoms = new Float32Array(particleCount);
                        
                        // æ ‘çš„é…ç½® - ç¼©å°å°ºå¯¸
                        const treeHeight = 8;
                        const radiusBase = 3;
                        const scatterRadius = 12;
                        
                        for (let i = 0; i < particleCount; i++) {
                            const i3 = i * 3;
                            
                            // æ•£å¼€ä½ç½® - çƒå½¢åˆ†å¸ƒ
                            const phi = Math.acos(-1 + (2 * Math.random()));
                            const theta = Math.sqrt(particleCount * Math.PI) * phi;
                            const radius = Math.cbrt(Math.random()) * scatterRadius;
                            
                            scatterPositions[i3] = radius * Math.cos(theta) * Math.sin(phi);
                            scatterPositions[i3 + 1] = radius * Math.cos(phi);
                            scatterPositions[i3 + 2] = radius * Math.sin(theta) * Math.sin(phi);
                            
                            // æ ‘å½¢ä½ç½® - åœ†é”¥å½¢åˆ†å¸ƒ
                            const y = (Math.random() - 0.2) * treeHeight;
                            const normY = 1 - (y + treeHeight * 0.2) / treeHeight;
                            const radiusAtHeight = Math.max(0, normY * radiusBase);
                            const angle = Math.random() * Math.PI * 2;
                            const r = Math.sqrt(Math.random()) * radiusAtHeight;
                            
                            treePositions[i3] = Math.cos(angle) * r;
                            treePositions[i3 + 1] = y - 2; // è°ƒæ•´Yåç§»
                            treePositions[i3 + 2] = Math.sin(angle) * r;
                            
                            // åˆå§‹ä½ç½®è®¾ä¸ºæ•£å¼€çŠ¶æ€
                            positions[i3] = scatterPositions[i3];
                            positions[i3 + 1] = scatterPositions[i3 + 1];
                            positions[i3 + 2] = scatterPositions[i3 + 2];
                            
                            // é¢œè‰² - ç»¿è‰²ç³»å˜åŒ–
                            const colorVariation = Math.random();
                            if (colorVariation > 0.9) {
                                // é‡‘è‰²äº®ç‚¹
                                colors[i3] = 1.0;
                                colors[i3 + 1] = 0.8;
                                colors[i3 + 2] = 0.2;
                            } else {
                                // ç»¿è‰²ä¸»ä½“
                                colors[i3] = 0.1 + Math.random() * 0.2;
                                colors[i3 + 1] = 0.4 + Math.random() * 0.4;
                                colors[i3 + 2] = 0.1 + Math.random() * 0.3;
                            }
                            
                            sizes[i] = Math.random() * 3 + 1;
                            randoms[i] = Math.random();
                        }
                        
                        const geometry = new THREE.BufferGeometry();
                        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                        
                        const material = new THREE.PointsMaterial({
                            size: 0.05,
                            vertexColors: true,
                            transparent: true,
                            opacity: 0.8,
                            sizeAttenuation: true,
                            blending: THREE.AdditiveBlending
                        });
                        
                        const particles = new THREE.Points(geometry, material);
                        scene.add(particles);
                        particlesRef.current = { 
                            mesh: particles, 
                            scatterPositions, 
                            treePositions, 
                            randoms 
                        };
                        
                        // åˆ›å»ºè£…é¥°å“ - å¢åŠ æ•°é‡å’Œç§ç±»
                        const ornamentCount = 150;
                        const lightCount = 100;
                        const giftCount = 30;
                        
                        // å½©çƒè£…é¥°
                        const ornamentGeometry = new THREE.SphereGeometry(0.08, 8, 8);
                        const ornamentMaterials = [
                            new THREE.MeshStandardMaterial({ color: '#ff4757', metalness: 0.8, roughness: 0.2 }),
                            new THREE.MeshStandardMaterial({ color: '#FFD700', metalness: 0.9, roughness: 0.1 }),
                            new THREE.MeshStandardMaterial({ color: '#2ed573', metalness: 0.7, roughness: 0.3 }),
                            new THREE.MeshStandardMaterial({ color: '#3742fa', metalness: 0.8, roughness: 0.2 }),
                            new THREE.MeshStandardMaterial({ color: '#ff6b6b', metalness: 0.6, roughness: 0.4 })
                        ];
                        
                        const ornaments = [];
                        for (let i = 0; i < ornamentCount; i++) {
                            const ornament = new THREE.Mesh(
                                ornamentGeometry, 
                                ornamentMaterials[Math.floor(Math.random() * ornamentMaterials.length)]
                            );
                            
                            // æ›´å¥½çš„æ ‘å½¢åˆ†å¸ƒ
                            const y = Math.random() * treeHeight - 2;
                            const normY = Math.max(0, 1 - (y + 2) / treeHeight);
                            const radius = normY * radiusBase * 0.8;
                            const angle = Math.random() * Math.PI * 2;
                            const r = Math.random() * radius;
                            
                            ornament.position.set(
                                Math.cos(angle) * r,
                                y,
                                Math.sin(angle) * r
                            );
                            
                            ornament.userData = {
                                originalPosition: ornament.position.clone(),
                                scatterPosition: new THREE.Vector3(
                                    (Math.random() - 0.5) * scatterRadius,
                                    (Math.random() - 0.5) * scatterRadius,
                                    (Math.random() - 0.5) * scatterRadius
                                ),
                                rotationSpeed: Math.random() * 0.02 + 0.01
                            };
                            
                            scene.add(ornament);
                            ornaments.push(ornament);
                        }
                        
                        // å‘å…‰ç¯æ³¡
                        const lightBulbGeometry = new THREE.SphereGeometry(0.05, 6, 6);
                        const lightBulbMaterial = new THREE.MeshBasicMaterial({ 
                            color: '#FFF6B5',
                            transparent: true,
                            opacity: 0.9
                        });
                        
                        const lightBulbs = [];
                        for (let i = 0; i < lightCount; i++) {
                            const bulb = new THREE.Mesh(lightBulbGeometry, lightBulbMaterial);
                            
                            const y = Math.random() * treeHeight - 2;
                            const normY = Math.max(0, 1 - (y + 2) / treeHeight);
                            const radius = normY * radiusBase * 0.9;
                            const angle = Math.random() * Math.PI * 2;
                            const r = Math.random() * radius;
                            
                            bulb.position.set(
                                Math.cos(angle) * r,
                                y,
                                Math.sin(angle) * r
                            );
                            
                            // æ·»åŠ ç‚¹å…‰æº
                            const pointLight = new THREE.PointLight('#FFF6B5', 0.5, 2, 2);
                            pointLight.position.copy(bulb.position);
                            scene.add(pointLight);
                            
                            bulb.userData = {
                                originalPosition: bulb.position.clone(),
                                scatterPosition: new THREE.Vector3(
                                    (Math.random() - 0.5) * scatterRadius,
                                    (Math.random() - 0.5) * scatterRadius,
                                    (Math.random() - 0.5) * scatterRadius
                                ),
                                light: pointLight,
                                blinkPhase: Math.random() * Math.PI * 2
                            };
                            
                            scene.add(bulb);
                            lightBulbs.push(bulb);
                        }
                        
                        // ç¤¼ç‰©ç›’
                        const giftGeometry = new THREE.BoxGeometry(0.15, 0.15, 0.15);
                        const giftMaterials = [
                            new THREE.MeshStandardMaterial({ color: '#ff4757' }),
                            new THREE.MeshStandardMaterial({ color: '#2ed573' }),
                            new THREE.MeshStandardMaterial({ color: '#3742fa' }),
                            new THREE.MeshStandardMaterial({ color: '#ff9ff3' })
                        ];
                        
                        const gifts = [];
                        for (let i = 0; i < giftCount; i++) {
                            const gift = new THREE.Mesh(
                                giftGeometry,
                                giftMaterials[Math.floor(Math.random() * giftMaterials.length)]
                            );
                            
                            // ç¤¼ç‰©ä¸»è¦åœ¨æ ‘åº•éƒ¨
                            const y = -2 + Math.random() * 2;
                            const radius = radiusBase * 0.6;
                            const angle = Math.random() * Math.PI * 2;
                            const r = Math.random() * radius;
                            
                            gift.position.set(
                                Math.cos(angle) * r,
                                y,
                                Math.sin(angle) * r
                            );
                            
                            gift.rotation.set(
                                Math.random() * Math.PI,
                                Math.random() * Math.PI,
                                Math.random() * Math.PI
                            );
                            
                            gift.userData = {
                                originalPosition: gift.position.clone(),
                                originalRotation: gift.rotation.clone(),
                                scatterPosition: new THREE.Vector3(
                                    (Math.random() - 0.5) * scatterRadius,
                                    (Math.random() - 0.5) * scatterRadius,
                                    (Math.random() - 0.5) * scatterRadius
                                ),
                                rotationSpeed: Math.random() * 0.01 + 0.005
                            };
                            
                            scene.add(gift);
                            gifts.push(gift);
                        }
                        
                        // åˆ›å»ºé¡¶éƒ¨æ˜Ÿæ˜Ÿ - æ”¹ä¸ºäº”è§’æ˜Ÿå½¢çŠ¶
                        const starShape = new THREE.Shape();
                        const outerRadius = 0.3;
                        const innerRadius = 0.15;
                        const points = 5;
                        
                        for (let i = 0; i < points * 2; i++) {
                            const r = (i % 2 === 0) ? outerRadius : innerRadius;
                            const a = (i / (points * 2)) * Math.PI * 2 - Math.PI / 2;
                            const x = Math.cos(a) * r;
                            const y = Math.sin(a) * r;
                            
                            if (i === 0) starShape.moveTo(x, y);
                            else starShape.lineTo(x, y);
                        }
                        starShape.closePath();
                        
                        const starGeometry = new THREE.ExtrudeGeometry(starShape, {
                            depth: 0.1,
                            bevelEnabled: true,
                            bevelThickness: 0.02,
                            bevelSize: 0.02,
                            bevelSegments: 2
                        });
                        
                        const starMaterial = new THREE.MeshStandardMaterial({
                            color: '#FFD700',
                            emissive: '#FFD700',
                            emissiveIntensity: 0.8,
                            metalness: 1.0,
                            roughness: 0.1
                        });
                        const star = new THREE.Mesh(starGeometry, starMaterial);
                        star.position.set(0, 4, 0); // è°ƒæ•´æ˜Ÿæ˜Ÿä½ç½®
                        scene.add(star);
                        
                        // æ·»åŠ æ˜Ÿæ˜Ÿå…‰æº
                        const starLight = new THREE.PointLight('#fff6b5', 2, 5, 2);
                        starLight.position.copy(star.position);
                        scene.add(starLight);
                        
                        // æ·»åŠ æ˜Ÿç©ºèƒŒæ™¯
                        const starsGeometry = new THREE.BufferGeometry();
                        const starsCount = 5000;
                        const starsPositions = new Float32Array(starsCount * 3);
                        
                        for (let i = 0; i < starsCount * 3; i++) {
                            starsPositions[i] = (Math.random() - 0.5) * 200;
                        }
                        
                        starsGeometry.setAttribute('position', new THREE.BufferAttribute(starsPositions, 3));
                        const starsMaterial = new THREE.PointsMaterial({ 
                            color: '#ffffff', 
                            size: 0.5,
                            transparent: true,
                            opacity: 0.8
                        });
                        const starsField = new THREE.Points(starsGeometry, starsMaterial);
                        scene.add(starsField);
                        
                        // åŠ¨ç”»å¾ªç¯
                        let currentMorph = 0;
                        const targetMorph = () => treeState === 'TREE_SHAPE' ? 1.0 : 0.0;
                        
                        const animate = () => {
                            frameId.current = requestAnimationFrame(animate);
                            timeRef.current += 0.016;
                            
                            // å¹³æ»‘æ’å€¼åˆ°ç›®æ ‡çŠ¶æ€
                            const target = targetMorph();
                            currentMorph += (target - currentMorph) * 0.02;
                            
                            // æ›´æ–°ç²’å­ä½ç½®
                            if (particlesRef.current) {
                                const { mesh, scatterPositions, treePositions, randoms } = particlesRef.current;
                                const positions = mesh.geometry.attributes.position.array;
                                
                                for (let i = 0; i < particleCount; i++) {
                                    const i3 = i * 3;
                                    
                                    // æ·»åŠ å™ªå£°è¿åŠ¨
                                    const noise = Math.sin(timeRef.current * 2 + randoms[i] * 10) * 0.1 * (1 - currentMorph);
                                    
                                    // æ’å€¼ä½ç½®
                                    positions[i3] = scatterPositions[i3] + (treePositions[i3] - scatterPositions[i3]) * currentMorph + noise;
                                    positions[i3 + 1] = scatterPositions[i3 + 1] + (treePositions[i3 + 1] - scatterPositions[i3 + 1]) * currentMorph + Math.cos(timeRef.current + randoms[i] * 5) * 0.05;
                                    positions[i3 + 2] = scatterPositions[i3 + 2] + (treePositions[i3 + 2] - scatterPositions[i3 + 2]) * currentMorph + noise;
                                }
                                
                                mesh.geometry.attributes.position.needsUpdate = true;
                                
                                // æ›´æ–°æè´¨é€æ˜åº¦
                                mesh.material.opacity = 0.6 + 0.4 * currentMorph;
                            }
                            
                            // æ›´æ–°è£…é¥°å“
                            ornaments.forEach(ornament => {
                                const { originalPosition, scatterPosition, rotationSpeed } = ornament.userData;
                                
                                ornament.position.lerpVectors(scatterPosition, originalPosition, currentMorph);
                                ornament.rotation.y += rotationSpeed * (1 + (1 - currentMorph) * 2);
                                ornament.rotation.x += rotationSpeed * 0.5;
                                
                                // æ·»åŠ æµ®åŠ¨æ•ˆæœ
                                ornament.position.y += Math.sin(timeRef.current * 3 + ornament.position.x) * 0.02;
                            });
                            
                            // æ›´æ–°ç¯æ³¡
                            lightBulbs.forEach(bulb => {
                                const { originalPosition, scatterPosition, light, blinkPhase } = bulb.userData;
                                
                                bulb.position.lerpVectors(scatterPosition, originalPosition, currentMorph);
                                light.position.copy(bulb.position);
                                
                                // é—ªçƒæ•ˆæœ
                                const blink = Math.sin(timeRef.current * 4 + blinkPhase) * 0.5 + 0.5;
                                bulb.material.opacity = 0.6 + blink * 0.4;
                                light.intensity = (0.3 + blink * 0.4) * currentMorph;
                            });
                            
                            // æ›´æ–°ç¤¼ç‰©
                            gifts.forEach(gift => {
                                const { originalPosition, originalRotation, scatterPosition, rotationSpeed } = gift.userData;
                                
                                gift.position.lerpVectors(scatterPosition, originalPosition, currentMorph);
                                gift.rotation.y += rotationSpeed * (1 + (1 - currentMorph) * 3);
                                gift.rotation.x += rotationSpeed * 0.3;
                            });
                            
                            // æ›´æ–°æ˜Ÿæ˜Ÿ
                            star.rotation.y = timeRef.current * 0.5;
                            star.rotation.z = Math.sin(timeRef.current * 2) * 0.1;
                            star.position.y = 4 + Math.sin(timeRef.current * 2) * 0.05;
                            star.scale.setScalar(1 + Math.sin(timeRef.current * 3) * 0.03);
                            starLight.position.copy(star.position);
                            
                            // ç›¸æœºè‡ªåŠ¨æ—‹è½¬ï¼ˆå½“æ ‘å½¢æˆæ—¶ï¼‰- è°ƒæ•´åŠå¾„
                            if (currentMorph > 0.5) {
                                const radius = 12;
                                camera.position.x = Math.sin(timeRef.current * 0.1) * radius;
                                camera.position.z = Math.cos(timeRef.current * 0.1) * radius;
                                camera.lookAt(0, 0, 0);
                            }
                            
                            // æ˜Ÿç©ºæ—‹è½¬
                            starsField.rotation.y = timeRef.current * 0.0005;
                            
                            renderer.render(scene, camera);
                        };
                        
                        animate();
                        
                        // å¤„ç†çª—å£å¤§å°å˜åŒ–
                        const handleResize = () => {
                            camera.aspect = window.innerWidth / window.innerHeight;
                            camera.updateProjectionMatrix();
                            renderer.setSize(window.innerWidth, window.innerHeight);
                        };
                        
                        window.addEventListener('resize', handleResize);
                        
                        return () => {
                            window.removeEventListener('resize', handleResize);
                            if (frameId.current) {
                                cancelAnimationFrame(frameId.current);
                            }
                            if (mountRef.current && renderer.domElement) {
                                mountRef.current.removeChild(renderer.domElement);
                            }
                            renderer.dispose();
                        };
                        
                    } catch (error) {
                        console.error('Error in ThreeScene:', error);
                        showError(error);
                    }
                }, [treeState]);
                
                return React.createElement('div', { 
                    ref: mountRef, 
                    style: { position: 'absolute', top: 0, left: 0, width: '100%', height: '100%' } 
                });
            };
            
            // è¦†ç›–å±‚ç»„ä»¶
            const Overlay = ({ treeState, toggleState }) => {
                const isTree = treeState === 'TREE_SHAPE';
                
                return React.createElement('div', {
                    className: 'absolute inset-0 pointer-events-none flex flex-col justify-between items-center p-8 z-10'
                }, [
                    React.createElement('header', { key: 'header', className: 'text-center mt-4' }, [
                        React.createElement('h1', {
                            key: 'title',
                            className: 'text-3xl md:text-5xl text-transparent bg-clip-text bg-gradient-to-b from-yellow-200 to-yellow-600 font-bold tracking-widest drop-shadow-lg uppercase',
                            style: { fontFamily: 'Cinzel, serif' }
                        }, 'Christmas Tree'),
                        React.createElement('h2', {
                            key: 'subtitle',
                            className: 'text-green-400 italic text-xl md:text-2xl mt-2 tracking-wide opacity-80',
                            style: { fontFamily: 'Playfair Display, serif' }
                        }, 'Merry Christmas')
                    ]),
                    React.createElement('div', {
                        key: 'controls',
                        className: 'mb-12 pointer-events-auto'
                    }, [
                        React.createElement('button', {
                            key: 'button',
                            onClick: toggleState,
                            className: `px-8 py-3 text-sm md:text-lg tracking-widest font-bold border border-yellow-500 transition-all duration-500 backdrop-blur-sm ${isTree ? 'bg-green-900 bg-opacity-20 text-yellow-400' : 'bg-transparent text-yellow-400'} hover:bg-yellow-500 hover:text-black`,
                            style: { fontFamily: 'Cinzel, serif' }
                        }, isTree ? 'SCATTER ESSENCE' : 'ASSEMBLE FORM')
                    ]),
                    React.createElement('div', {
                        key: 'footer',
                        className: 'absolute bottom-4 left-4 text-green-400 text-xs tracking-widest opacity-50',
                        style: { fontFamily: 'Cinzel, serif' }
                    }, 'INTERACTIVE 3D EXPERIENCE')
                ]);
            };
            
            // ä¸»åº”ç”¨ç»„ä»¶
            const App = () => {
                const [treeState, setTreeState] = useState('SCATTERED');
                
                const toggleState = () => {
                    setTreeState(prev => prev === 'SCATTERED' ? 'TREE_SHAPE' : 'SCATTERED');
                };
                
                // é”®ç›˜æ§åˆ¶
                useEffect(() => {
                    const handleKeyDown = (e) => {
                        if (e.code === 'Space') {
                            e.preventDefault();
                            toggleState();
                        }
                    };
                    
                    window.addEventListener('keydown', handleKeyDown);
                    return () => window.removeEventListener('keydown', handleKeyDown);
                }, []);
                
                return React.createElement('div', {
                    className: 'w-full h-screen bg-black relative overflow-hidden'
                }, [
                    React.createElement(ThreeScene, { key: 'scene', treeState }),
                    React.createElement(Overlay, { key: 'overlay', treeState, toggleState }),
                    React.createElement('div', {
                        key: 'border',
                        className: 'absolute inset-0 pointer-events-none border border-yellow-500 border-opacity-20 m-4 z-20'
                    })
                ]);
            };
            
            // æ¸²æŸ“åº”ç”¨
            const root = ReactDOM.createRoot(document.getElementById('root'));
            root.render(React.createElement(App));
            
            console.log('ğŸ„ 3D Christmas Tree with 12000 particles loaded successfully! ğŸ„');
            console.log('âœ¨ Press SPACE or click the button to toggle between scattered and tree form! âœ¨');
        }
    </script>
</body>
</html>
